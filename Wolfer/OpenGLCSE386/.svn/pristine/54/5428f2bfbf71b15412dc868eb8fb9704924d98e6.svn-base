//#include <math.h>
//#define GLM_MESSAGES
//#define GLM_FORCE_RADIANS

#define M_PI        3.14159265358979323846264338327950288f   /* pi */

#define GLM_SWIZZLE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/swizzle.hpp>

using namespace glm;
 
#include "OpenGLApplicationBase.h"

#include "ColoredPyramid.h"
#include "Floor.h"
#include "Pyramid.h"

static GLint view = 0;

class bachmaerLab3 : public OpenGLApplicationBase
{
public:

	bachmaerLab3()
	{
		pyramid0 = new Pyramid( this );
		pyramid1 = new ColoredPyramid( this );
		pyramid2 = new ColoredPyramid( this, 2.0f, 2.0f );
		pyramid3 = new ColoredPyramid( this );
		pyramid4 = new ColoredPyramid( this );
		floor = new Floor(this);
	};


	~bachmaerLab3()
	{
		delete pyramid0;
		delete pyramid1;
		delete pyramid2;
		delete pyramid3;
		delete pyramid4;
		delete floor;
	};



	mat4 createPerspectiveProjectionmatrix(float fov, int width, int height, float zNear, float zFar) 
	{
		mat4 p(0.0f); // Create 4 x 4 matrix with all elements set to zero
		
		float zRange = zNear - zFar;
		float ar = (float)width / (float)height;
		float radianFov = fov * M_PI / 180.0f;
		float tanHalfFov = tanf(radianFov / 2.0f);

		// In GLM, matrix elements are access by [col][row]
		p[0][0] = 1.0f/(tanHalfFov * ar); 

		p[1][1] = 1.0f/tanHalfFov;
 
		p[2][2] = (zNear + zFar)/zRange;
		p[3][2] = (2.0f * zFar*zNear)/zRange; 
      
        p[2][3] = -1.0f;                

		return p;
	}

	void ReshapeCB(int windowWidth, int windowHeight)
{
	cout << "Window sized to " << windowWidth << " x " << windowHeight << endl;

	// Set viewport to entire client area of the window
	glViewport(0, 0, windowWidth, windowHeight);

	// Set up a perspective projection matrix with a 45 degree vertical FOV.
	// Aspect ratio equals that of the rendering window.
	// Sets the near and far clipping planes at point one and one hundred units. 
//	ProjectionMatrix = perspective(45.0f, (GLfloat)windowWidth / (GLfloat)windowHeight, 0.1f, 100.0f);
	ProjectionMatrix = createPerspectiveProjectionmatrix( 45.0f, windowWidth, windowHeight, 0.1f, 100.0f);
} // end ReshapeCB


    virtual bool initialize()
    {
		glClearColor(0.5f, 0.5f, 1.0f, 0.0f);
		glFrontFace(GL_CCW);
		glCullFace(GL_BACK);
		glEnable(GL_CULL_FACE);

		glEnable( GL_DEPTH_TEST );

		setUpMenus();

		// Set the viewing transformation that will be used to render all objects 
		// in the scene.
		this->ViewMatrix = translate(mat4(1.0f), vec3( 0.0f, 0.0f,-12.0f ));

		pyramid0->initialize();
		pyramid0->modelMatrix = rotate(mat4(1.0f), 45.0f, vec3(0.0f, 1.0f, 0.0f)); 

		pyramid1->initialize();
		T1 = translate(mat4(1.0f), vec3(3.0f, 0.0, 0.0f));
		pyramid1->modelMatrix = rotate(T1, 45.0f, vec3(1.0f, 0.0f, 0.0f));

		pyramid2->initialize();
		T2 = translate(mat4(1.0f), vec3(-3.0f, 0.0, 0.0f));
		pyramid2->modelMatrix = rotate(T2, 45.0f, vec3(0.0f, 0.0f, 1.0f));

		pyramid3->initialize();
		T3 = translate(mat4(1.0f), vec3(10.0f, 0.0, 0.0f));
		R30 = rotate(mat4(1.0f), 65.0f, vec3(0.0f, 1.0f, 0.0f));
		pyramid3->modelMatrix = R30 * T3;

		pyramid4->initialize();
		P4 = vec3( 3.5f, -2.5f, 3.5f );
		pyramid4->modelMatrix = translate(mat4(1.0f), P4);
	
		floor->initialize();
		floor->modelMatrix = translate(mat4(1.0f), vec3( 0.0f, -3.0f, 0.0f ));// * rotate(mat4(1.0f), 90.0f, vec3(1.0f, 0.0f, 0.0f));

		return true;

    } // end initialize


	// Render scene objects
	virtual void drawScene()
	{ 
		pyramid0->draw();
		pyramid1->draw();
		pyramid2->draw();
		pyramid3->draw();
		pyramid4->draw();
		floor->draw();

	} // end drawScene


	// Update scene objects inbetween frames
	virtual void updateScene( float elapsedTimeSec ) 
	{
		static float rotation = 0.0f;

		rotation += elapsedTimeSec * 25.0f;

		pyramid0->modelMatrix = rotate(mat4(1.0f), fmod(rotation, 360.0f), vec3(0.0f, 1.0f, 0.0f)); //mat4(1.0f);
		pyramid0->update( elapsedTimeSec);

		pyramid1->modelMatrix = rotate(T1, fmod(rotation, 360.0f), vec3(1.0f, 0.0f, 0.0f));
		pyramid1->update( elapsedTimeSec);

		pyramid2->modelMatrix = rotate(T2, fmod(rotation, 360.0f), vec3(0.0f, 0.0f, 1.0f));
		pyramid2->update( elapsedTimeSec);

		R30 = rotate(mat4(1.0f), fmod(-rotation, 360.0f), vec3(0.0f, 1.0f, 0.0f));
		R31 = rotate(mat4(1.0f), fmod(rotation * 4.0f, 360.0f), vec3(1.0f, 0.0f, 0.0f));
		pyramid3->modelMatrix = R30 * T3 * R31;
		pyramid3->update( elapsedTimeSec);

		static vec3 i = vec3(1.0f, 0.0f, 0.0); 
		static vec3 k = vec3(0.0f, 0.0f, 1.0); 

		static vec3 velocity = -k;
		static int leg = 0;

		switch (leg) {

			case 0:

				if (P4.z <= -3.5) {
					P4.z = -3.5;
					velocity = -i;
					leg = 1;
				}
				break;
			case 1:

				if (P4.x <= -3.5) {
					P4.x = -3.5;
					velocity = k;
					leg = 2;
				}
				break;
			case 2:

				if (P4.z >= 3.5) {
					P4.z = 3.5;
					velocity = i;
					leg = 3;
				}
				break;
			case 3:

				if (P4.x >= 3.5) {
					P4.x = 3.5;
					velocity = -k;
					leg = 0;
				}
				break;
			default:
				cout << "invalid leg" << endl;
				break;
		}
		
		P4 = P4 + velocity * elapsedTimeSec;
		pyramid4->modelMatrix = translate(mat4(1.0f), P4);
		pyramid4->update( elapsedTimeSec);
		
		floor->update(elapsedTimeSec);
	} 

	friend void viewMenu(int value);

	GLuint createViewMenu() 
	{
		// Create polygon submenu
		GLuint menuId = glutCreateMenu(viewMenu);
		// Specify menu items and their integer indentifiers
		glutAddMenuEntry("default", 0);
		glutAddMenuEntry("View 1", 1);
		glutAddMenuEntry("View 2", 2);
		glutAddMenuEntry("View 3", 2);
		glutAddMenuEntry("View 4", 2);
		glutAddMenuEntry("View 5", 2);
		glutAddMenuEntry("View 6", 2);
		return menuId;

	} // end createFigureMenu

	
	friend void mainMenu(int value);

	void setUpMenus()
	{	
		GLuint menu1id = createViewMenu();
		GLuint menu2id = createPolygonMenu();
		GLuint menu3id = createFrontFaceMenu();
		GLuint menu4id = createPointSizeMenu();
		GLuint menu5id = createAntialiasingMenu();

		// Create main menu
		topMenu = glutCreateMenu(mainMenu);
		glutAddSubMenu("View", menu1id); 
		glutAddSubMenu("Polygon Mode", menu2id); 
		glutAddSubMenu("Rendered Polygon Face ", menu3id);
		glutAddSubMenu("Point Size ", menu4id);
		glutAddSubMenu("Antialiasing ", menu5id);
		glutAddMenuEntry("Quit", 1); // Specify indentifier for "Quit"			  
		glutAttachMenu(GLUT_RIGHT_BUTTON); // Attach menu to right mouse button

	} //end setUpMenus

	Pyramid * pyramid0;
	ColoredPyramid * pyramid1, *pyramid2, *pyramid3, *pyramid4;
	mat4 T1, T2, T3, R30, R31, T4; 
	vec3 P4;
	Floor* floor;

}; // end bachmaerLab3


void viewMenu(int value)
{
	view = value;
	cout << "View " << value << endl;

} // end figureMenu


void mainMenu(int value)
{
	switch (value) {

		case(1):
			glutLeaveMainLoop(); // End the program
			break;
		default:
			cout << "Unknown Main Menu Selection!" << endl;
	}

} // end mainMenu



int main(int argc, char** argv)
{
    GLUTBaseInit(argc, argv);

	GLUTBaseCreateWindow( "CSE 386 Lab 3" );

    bachmaerLab3 pApp;
	
	pApp.initialize();

	GLUTBaseRunApplication(&pApp);

    return 0;

} // end main