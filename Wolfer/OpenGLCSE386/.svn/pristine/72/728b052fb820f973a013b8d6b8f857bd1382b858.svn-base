//#include <math.h>
//#define GLM_MESSAGES
//#define GLM_FORCE_RADIANS

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

using namespace glm;
 
#include "OpenGLApplicationBase.h"

#include "ColoredPyramid.h"
#include "Floor.h"

static GLint figure = 1;

class bachmaerLab3 : public OpenGLApplicationBase
{
public:

	bachmaerLab3()
	{
		cp = new ColoredPyramid( this );
		floor = new Floor(this);
	};

	~bachmaerLab3()
	{
		delete cp;
		delete floor;
	};


    virtual bool initialize()
    {
		glClearColor(0.5f, 0.5f, 1.0f, 0.0f);
		glFrontFace(GL_CCW);
		glCullFace(GL_BACK);
		glEnable(GL_CULL_FACE);

		setUpMenus();

		// Set the viewing transformation that will be used to render all objects 
		// in the scene.
		this->ViewMatrix = translate(mat4(1.0f), vec3( 0.0f, 0.0f,-12.0f ));

		cp->initialize();
		cp->modelMatrix = rotate(mat4(1.0f), 45.0f, vec3(0.0f, 1.0f, 0.0f)); //mat4(1.0f);
	
		floor->initialize();
		floor->modelMatrix = translate(mat4(1.0f), vec3( 0.0f, -3.0f, 0.0f ));// * rotate(mat4(1.0f), 90.0f, vec3(1.0f, 0.0f, 0.0f));

		return true;

    } // end initialize

	// Render scene objects
	virtual void drawScene()
	{ 
		cp->draw();
		floor->draw();

	} // end drawScene

	// Update scene objects inbetween frames
	virtual void updateScene( float elapsedTimeSec ) 
	{ 
		static float rotation = 0.0f;

		rotation += elapsedTimeSec * 25.0f;

		cp->modelMatrix = rotate(mat4(1.0f), fmod(rotation, 360.0f), vec3(0.0f, 1.0f, 0.0f)); //mat4(1.0f);
		cp->update( elapsedTimeSec);
	//	cp->update( elapsedTimeSec );
	//	floor->update( elapsedTimeSec );

	//		static float rotation = 0.0;

	//rotation += elapsedTimeSeconds * 45;

	//rotate(mat4(1.0f), fmod(rotation, 360.0f), vec3(1.0, 1.0, 1.0));

	//mat4 modelView = View * rotate(mat4(1.0f), fmod(rotation, 360.0f), vec3(1.0, 0.0, 0.0));
		
		floor->update(elapsedTimeSec);
	} 

	friend void figureMenu(int value);

	GLuint createFigureMenu() 
	{
		// Create polygon submenu
		GLuint menuId = glutCreateMenu(figureMenu);
		// Specify menu items and their integer indentifiers
		glutAddMenuEntry("Figure 1", 1);
		glutAddMenuEntry("Figure 2", 2);

		return menuId;

	} // end createFigureMenu

	
	friend void mainMenu(int value);

	void setUpMenus()
	{	
		GLuint menu2id = createPolygonMenu();
		GLuint menu3id = createFrontFaceMenu();

		// Create main menu
		topMenu = glutCreateMenu(mainMenu);
		glutAddSubMenu("Polygon Mode", menu2id); 
		glutAddSubMenu("Rendered Polygon Face ", menu3id);
		glutAddMenuEntry("Quit", 1); // Specify indentifier for "Quit"			  
		glutAttachMenu(GLUT_RIGHT_BUTTON); // Attach menu to right mouse button

	} //end setUpMenus

	ColoredPyramid * cp;
	Floor* floor;

}; // end bachmaerLab3


void figureMenu(int value)
{
	figure = value;
	cout << "Drawing figure " << value << endl;

} // end figureMenu


void mainMenu(int value)
{
	switch (value) {

		case(1):
			glutLeaveMainLoop(); // End the program
			break;
		default:
			cout << "Unknown Main Menu Selection!" << endl;
	}

} // end mainMenu



int main(int argc, char** argv)
{
    GLUTBaseInit(argc, argv);

	GLUTBaseCreateWindow( "CSE 386 Lab3" );

    bachmaerLab3 pApp;
	
	pApp.initialize();

	GLUTBaseRunApplication(&pApp);

    return 0;

} // end main